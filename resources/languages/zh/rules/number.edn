[#clj-duckling.engine/rule {:name "integer (0..10)", :pattern "#\"〇|零|一|二|两|兩|三|四|五|六|七|八|九|十\"", :production "{:dim :number, :integer true, :value (get {\"零\" 0, \"七\" 7, \"十\" 10, \"一\" 1, \"五\" 5, \"二\" 2, \"八\" 8, \"两\" 2, \"三\" 3, \"兩\" 2, \"〇\" 0, \"九\" 9, \"六\" 6, \"四\" 4} (:text %1))}"}
 #clj-duckling.engine/rule {:name "integer (11..19)", :pattern "[#\"十\" (integer 1 9)]", :production "{:dim :number, :integer true, :value (+ 10 (:value %2))}"}
 #clj-duckling.engine/rule {:name "integer (20..90)", :pattern "[(integer 2 9) #\"十\"]", :production "{:dim :number, :integer true, :value (* (:value %1) 10)}"}
 #clj-duckling.engine/rule {:name "integer 21..99", :pattern "[(integer 20 90 (fn* [p1__3545#] (#{70 20 60 50 40 90 30 80} (:value p1__3545#)))) (integer 1 9)]", :production "{:dim :number, :integer true, :value (+ (:value %1) (:value %2))}"}
 #clj-duckling.engine/rule {:name "integer (numeric)", :pattern "#\"(\\d{1,18})\"", :production "{:dim :number, :integer true, :value (Long/parseLong (first (:groups %1)))}"}
 #clj-duckling.engine/rule {:name "integer with thousands separator ,", :pattern "#\"(\\d{1,3}(,\\d\\d\\d){1,5})\"", :production "{:dim :number, :integer true, :value (-> (:groups %1) first (clojure.string/replace #\",\" \"\") Long/parseLong)}"}
 #clj-duckling.engine/rule {:name "<number>个", :pattern "[(dim :number) #\"个\"]", :production "%1"}
 #clj-duckling.engine/rule {:name "decimal number", :pattern "#\"(\\d*\\.\\d+)\"", :production "{:dim :number, :value (Double/parseDouble (first (:groups %1)))}"}
 #clj-duckling.engine/rule {:name "decimal with thousands separator", :pattern "#\"(\\d+(,\\d\\d\\d)+\\.\\d+)\"", :production "{:dim :number, :value (-> (:groups %1) first (clojure.string/replace #\",\" \"\") Double/parseDouble)}"}
 #clj-duckling.engine/rule {:name "numbers prefix with -, negative or minus", :pattern "[#\"(?i)-|负\\s?|負\\s?\" (dim :number (fn* [p1__3546#] (not (:number-prefixed p1__3546#))))]", :production "(let [multiplier -1 value (* (:value %2) multiplier) int? (zero? (mod value 1)) value (if int? (long value) value)] (assoc %2 :value value :integer int? :number-prefixed true))"}
 #clj-duckling.engine/rule {:name "numbers suffixes (K, M, G)", :pattern "[(dim :number (fn* [p1__3547#] (not (:number-suffixed p1__3547#)))) #\"(?i)([kmg])\"]", :production "(let [multiplier (get {\"k\" 1000, \"m\" 1000000, \"g\" 1000000000} (-> %2 :groups first clojure.string/lower-case)) value (* (:value %1) multiplier) int? (zero? (mod value 1)) value (if int? (long value) value)] (assoc %1 :value value :integer int? :number-suffixed true))"}
 #clj-duckling.engine/rule {:name "ordinal (digits)", :pattern "[#\"第\" (dim :number)]", :production "{:dim :ordinal, :value (:value %2)}"}
 #clj-duckling.engine/rule {:name "integer (0..10)", :pattern "#\"[〇|零|一|二|两|兩|三|四|五|六|七|八|九|十][个個]\"", :production "{:dim :number, :integer true, :value (get {\"八个\" 8, \"〇个\" 0, \"零個\" 0, \"七个\" 7, \"零个\" 0, \"兩个\" 2, \"一個\" 1, \"七個\" 7, \"三个\" 3, \"两個\" 2, \"〇個\" 0, \"一个\" 1, \"九个\" 9, \"五个\" 5, \"九個\" 9, \"六個\" 6, \"两个\" 2, \"二个\" 2, \"二個\" 2, \"三個\" 3, \"四个\" 4, \"兩個\" 2, \"六个\" 6, \"五個\" 5, \"八個\" 8, \"四個\" 4, \"十個\" 10, \"十个\" 10} (:text %1))}"}]