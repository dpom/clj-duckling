[#clj-duckling.engine/rule {:name "integer (numeric)", :pattern "#\"(\\d{1,18})\"", :production "{:dim :number, :integer true, :value (Long/parseLong (first (:groups %1)))}"}
 #clj-duckling.engine/rule {:name "integer with thousands separator ,", :pattern "#\"(\\d{1,3}(,\\d\\d\\d){1,5})\"", :production "{:dim :number, :integer true, :value (-> (:groups %1) first (clojure.string/replace #\",\" \"\") Long/parseLong)}"}
 #clj-duckling.engine/rule {:name "integer 0", :pattern "#\"영|공|빵\"", :production "{:dim :number, :integer true, :value 0}"}
 #clj-duckling.engine/rule {:name "half - 반", :pattern "#\"반\"", :production "{:dim :number, :value 0.5}"}
 #clj-duckling.engine/rule {:name "few 몇", :pattern "#\"몇\"", :production "{:dim :number, :integer true, :precision :approximate, :value 3}"}
 #clj-duckling.engine/rule {:name "integer - TYPE 1", :pattern "#\"[일|이|삼|사|오|육|칠|팔|구|십|백|천|만|억|조]+\"", :production "(let [map-number (fn* [p1__3551#] (or (get {\\칠 7, \\육 6, \\오 5, \\사 4, \\구 9, \\십 1, \\백 1, \\팔 8, \\이 2, \\천 1, \\삼 3, \\일 1} p1__3551#) 0)) get-number (fn* [p1__3552#] (let [number (re-matches #\"(.*천)?(.*백)?(.*십)?(.*)?\" (or p1__3552# \"\"))] (+ (* 1000 (map-number (first (number 1)))) (* 100 (map-number (first (number 2)))) (* 10 (map-number (first (number 3)))) (map-number (first (number 4)))))) splited (re-matches #\"(.*조)?(.*억)?(.*만)?(.*)?\" (:text %1))] {:dim :number, :integer true, :value (+ (* 1000000000000 (get-number (splited 1))) (* 100000000 (get-number (splited 2))) (* 10000 (if (= (splited 3) \"만\") 1 (get-number (splited 3)))) (get-number (splited 4)))})"}
 #clj-duckling.engine/rule {:name "integer (1..10) - TYPE 2", :pattern "#\"하나|둘|셋|넷|다섯|여섯|일곱|여덟|아홉\"", :production "{:dim :number, :integer true, :value (get {\"여덟\" 8, \"아홉\" 9, \"넷\" 4, \"하나\" 1, \"여섯\" 6, \"둘\" 2, \"셋\" 3, \"다섯\" 5, \"일곱\" 7} (:text %1))}"}
 #clj-duckling.engine/rule {:name "integer (1..4) - for ordinals", :pattern "#\"한|첫|두|세|네\"", :production "{:dim :number, :integer true, :value (get {\"한\" 1, \"첫\" 1, \"두\" 2, \"세\" 3, \"네\" 4} (:text %1))}"}
 #clj-duckling.engine/rule {:name "integer (20..90) - TYPE 2 and ordinals", :pattern "#\"열|스물|서른|마흔|쉰|예순|일흔|여든|아흔\"", :production "{:dim :number, :integer true, :value (get {\"예순\" 60, \"서른\" 30, \"스물\" 20, \"열\" 10, \"일흔\" 70, \"마흔\" 40, \"여든\" 80, \"쉰\" 50, \"아흔\" 90} (:text %1))}"}
 #clj-duckling.engine/rule {:name "integer (21..99) - TYPE 2", :pattern "[(integer 10 90 (fn* [p1__3553#] (#{70 20 60 50 40 90 30 10 80} (:value p1__3553#)))) (integer 1 9)]", :production "{:dim :number, :integer true, :value (+ (:value %1) (:value %2))}"}
 #clj-duckling.engine/rule {:name "decimal number", :pattern "#\"(\\d*\\.\\d+)\"", :production "{:dim :number, :value (Double/parseDouble (first (:groups %1)))}"}
 #clj-duckling.engine/rule {:name "number dot number - 삼점사", :pattern "[(dim :number (fn* [p1__3554#] (not (:number-prefixed p1__3554#)))) #\"(점|쩜)([일|이|삼|사|오|육|칠|팔|구|영]+)\"]", :production "{:dim :number, :value (->> (-> %2 :groups second) vec (map (fn* [p1__3555#] (get {\\칠 \"7\", \\영 \"0\", \\육 \"6\", \\오 \"5\", \\사 \"4\", \\구 \"9\", \\팔 \"8\", \\이 \"2\", \\삼 \"3\", \\일 \"1\"} p1__3555#))) clojure.string/join (str \"0.\") Double/parseDouble (+ (:value %1)))}"}
 #clj-duckling.engine/rule {:name "decimal with thousands separator", :pattern "#\"(\\d+(,\\d\\d\\d)+\\.\\d+)\"", :production "{:dim :number, :value (-> (:groups %1) first (clojure.string/replace #\",\" \"\") Double/parseDouble)}"}
 #clj-duckling.engine/rule {:name "numbers prefix with -, 마이너스, or 마이나스", :pattern "[#\"-|마이너스\\s?|마이나스\\s?\" (dim :number (fn* [p1__3556#] (not (:number-prefixed p1__3556#))))]", :production "(let [multiplier -1 value (* (:value %2) multiplier) int? (zero? (mod value 1)) value (if int? (long value) value)] (assoc %2 :value value :integer int? :number-prefixed true))"}
 #clj-duckling.engine/rule {:name "ordinals (첫번째)", :pattern "[(dim :number) #\"번째|째|째번\"]", :production "{:dim :ordinal, :value (:value %1)}"}
 #clj-duckling.engine/rule {:name "fraction", :pattern "[(dim :number (fn* [p1__3557#] (not (:number-prefixed p1__3557#)))) #\"분(의|에)\" (dim :number (fn* [p1__3558#] (not (:number-suffixed p1__3558#))))]", :production "{:dim :number, :value (/ (:value %3) (:value %1))}"}
 #clj-duckling.engine/rule {:name "fraction", :pattern "[(dim :number (fn* [p1__3559#] (not (:number-prefixed p1__3559#)))) #\"/\" (dim :number (fn* [p1__3560#] (not (:number-suffixed p1__3560#))))]", :production "{:dim :number, :value (/ (:value %1) (:value %3))}"}]