[#clj-duckling.engine/rule {:name "intersect", :pattern "[(dim :number :grain (fn* [p1__3545#] (> (:grain p1__3545#) 1))) (dim :number)]", :production "(compose-numbers %1 %2)"}
 #clj-duckling.engine/rule {:name "integer (0..9 11)", :pattern "#\"(?i)(kosong|nol|satu|dua|tiga|empat|lima|enam|tujuh|delapan|sembilan|sebelas)\"", :production "{:dim :number, :integer true, :value (get {\"dua\" 2, \"delapan\" 8, \"lima\" 5, \"enam\" 6, \"kosong\" 0, \"sebelas\" 11, \"tiga\" 3, \"satu\" 1, \"tujuh\" 7, \"nol\" 0, \"empat\" 4, \"sembilan\" 9} (-> %1 :groups first clojure.string/lower-case))}"}
 #clj-duckling.engine/rule {:name "ten", :pattern "#\"(?i)(se)?puluh\"", :production "{:dim :number, :integer true, :value 10, :grain 1}"}
 #clj-duckling.engine/rule {:name "teen", :pattern "[(integer 2 9) #\"belas\"]", :production "{:dim :number, :integer true, :value (+ (:value %1) 10)}"}
 #clj-duckling.engine/rule {:name "dozen", :pattern "#\"(?i)(se)?lusin\"", :production "{:dim :number, :integer true, :value 12, :grain 1, :grouping true}"}
 #clj-duckling.engine/rule {:name "hundred", :pattern "#\"(?i)(se)?ratus\"", :production "{:dim :number, :integer true, :value 100, :grain 2}"}
 #clj-duckling.engine/rule {:name "thousand", :pattern "#\"(?i)(se)?ribu\"", :production "{:dim :number, :integer true, :value 1000, :grain 3}"}
 #clj-duckling.engine/rule {:name "million", :pattern "#\"(?i)(se)?juta\"", :production "{:dim :number, :integer true, :value 1000000, :grain 6}"}
 #clj-duckling.engine/rule {:name "some/few/couple", :pattern "#\"beberapa\"", :production "{:dim :number, :integer true, :precision :approximate, :value 3}"}
 #clj-duckling.engine/rule {:name "integer 20..90", :pattern "[(integer 2 9) (integer 10 10)]", :production "{:dim :number, :integer true, :value (* (:value %1) (:value %2)), :grain (:grain %2)}"}
 #clj-duckling.engine/rule {:name "integer 21..99", :pattern "[(integer 10 90 (fn* [p1__3546#] (#{70 20 60 50 40 90 30 80} (:value p1__3546#)))) (integer 1 9)]", :production "{:dim :number, :integer true, :value (+ (:value %1) (:value %2))}"}
 #clj-duckling.engine/rule {:name "integer (numeric)", :pattern "#\"(\\d{1,18})\"", :production "{:dim :number, :integer true, :value (Long/parseLong (first (:groups %1)))}"}
 #clj-duckling.engine/rule {:name "integer with thousands separator .", :pattern "#\"(\\d{1,3}(\\.\\d\\d\\d){1,5})\"", :production "{:dim :number, :integer true, :value (-> (:groups %1) first (clojure.string/replace #\"\\.\" \"\") Long/parseLong)}"}
 #clj-duckling.engine/rule {:name "number hundreds", :pattern "[(integer 2 99) (integer 100 100)]", :production "{:dim :number, :integer true, :value (* (:value %1) (:value %2)), :grain (:grain %2)}"}
 #clj-duckling.engine/rule {:name "number thousands", :pattern "[(integer 2 999) (integer 1000 1000)]", :production "{:dim :number, :integer true, :value (* (:value %1) (:value %2)), :grain (:grain %2)}"}
 #clj-duckling.engine/rule {:name "number millions", :pattern "[(integer 2 99) (integer 1000000 1000000)]", :production "{:dim :number, :integer true, :value (* (:value %1) (:value %2)), :grain (:grain %2)}"}
 #clj-duckling.engine/rule {:name "decimal number", :pattern "#\"(\\d*,\\d+)\"", :production "{:dim :number, :value (-> (:groups %1) first (clojure.string/replace #\",\" \".\") Double/parseDouble)}"}
 #clj-duckling.engine/rule {:name "number comma number", :pattern "[(dim :number (fn* [p1__3547#] (not (:number-prefixed p1__3547#)))) #\"(?i)koma\" (dim :number (fn* [p1__3548#] (not (:number-suffixed p1__3548#))))]", :production "{:dim :number, :value (+ (* 0.1 (:value %3)) (:value %1))}"}
 #clj-duckling.engine/rule {:name "decimal with thousands separator", :pattern "#\"(\\d+(\\.\\d\\d\\d)+,\\d+)\"", :production "{:dim :number, :value (-> (:groups %1) first (clojure.string/replace #\"\\.\" \"\") Double/parseDouble)}"}
 #clj-duckling.engine/rule {:name "numbers prefix with -, negative or minus", :pattern "[#\"(?i)-|minus\\s?|negatif\\s?\" (dim :number (fn* [p1__3549#] (not (:number-prefixed p1__3549#))))]", :production "(let [multiplier -1 value (* (:value %2) multiplier) int? (zero? (mod value 1)) value (if int? (long value) value)] (assoc %2 :value value :integer int? :number-prefixed true))"}
 #clj-duckling.engine/rule {:name "numbers suffixes (K, M, G)", :pattern "[(dim :number (fn* [p1__3550#] (not (:number-suffixed p1__3550#)))) #\"(?i)([kmg])(?=[\\W\\$â‚¬]|$)\"]", :production "(let [multiplier (get {\"k\" 1000, \"m\" 1000000, \"g\" 1000000000} (-> %2 :groups first clojure.string/lower-case)) value (* (:value %1) multiplier) int? (zero? (mod value 1)) value (if int? (long value) value)] (assoc %1 :value value :integer int? :number-suffixed true))"}
 #clj-duckling.engine/rule {:name "ordinals", :pattern "#\"(?i)(pertama|kedua|ketiga|keempat|kelima|keenam|ketujuh|kedelapan|kesembilan|kesepuluh)\"", :production "{:dim :ordinal, :value (get {\"ketiga\" 3, \"ketujuh\" 7, \"keenam\" 6, \"kesepuluh\" 10, \"kedua\" 2, \"pertama\" 1, \"kelima\" 5, \"keempat\" 4, \"kesembilan\" 9, \"kedelapan\" 8} (-> %1 :groups first clojure.string/lower-case))}"}
 #clj-duckling.engine/rule {:name "ordinals (digits)", :pattern "#\"ke-0*(\\d+)\"", :production "{:dim :ordinal, :value (read-string (first (:groups %1)))}"}]